# hakoniwa-pdu-javascript

`hakoniwa-pdu-javascript` is the official JavaScript/TypeScript runtime library for exchanging Packet Data Units (PDUs) with Hakoniwa-based simulators over WebSockets. It provides high level helpers for setting up client or server style transports, marshaling binary payloads, and exposing RPC services so that simulator components can collaborate in real time.

## Features

- ðŸ”Œ **Drop-in WebSocket transport** â€“ client and server implementations that speak the Hakoniwa wire protocol.
- ðŸ“¦ **PDU aware buffer management** â€“ track channel IDs, sizes, and raw shared-memory compatible buffers.
- ðŸ” **RPC helpers** â€“ quickly expose remote services or talk to existing ones without wiring by hand.
- ðŸ§© **Utility converters** â€“ encode/decode PDUs generated from Hakoniwa definitions.

## Prerequisites

- Node.js **18.x** or newer (required for native `WebSocket` and ES module support).
- npm **9.x** or newer (ships with modern Node.js releases).

## Installing the library

Install the package from npm inside your project:

```bash
npm install hakoniwa-pdu-javascript
```

If you are developing the library locally, clone the repository and install the development dependencies:

```bash
git clone https://github.com/hakoniwalab/hakoniwa-pdu-javascript.git
cd hakoniwa-pdu-javascript
npm install
```

## Quick start example

The following example shows how to bootstrap a client that connects to an existing Hakoniwa WebSocket bridge, declares PDUs for bidirectional traffic, and exchanges raw payloads.

```javascript
// examples/basic-client.js
import {
  PduManager,
  WebSocketCommunicationService
} from 'hakoniwa-pdu-javascript';
import { fileURLToPath } from 'url';
import path from 'path';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

const configPath = path.join(__dirname, 'sample-config.json');

async function main() {
  const manager = new PduManager({ wire_version: 'v2' });
  const transport = new WebSocketCommunicationService('v2');

  manager.initialize(configPath, transport);
  await manager.start_service('ws://127.0.0.1:8080');

  await manager.declare_pdu_for_readwrite('sample_robot', 'actuator_command');

  // Read the most recent sensor PDU into a typed view
  const sensorBuffer = manager.read_pdu_raw_data('sample_robot', 'sensor_state');
  if (sensorBuffer) {
    const view = new DataView(sensorBuffer);
    const timestamp = Number(view.getBigUint64(0, true));
    console.log('[sensor_state] timestamp =', timestamp);
  }

  // Write a command PDU and flush it to the simulator
  const commandBuffer = new ArrayBuffer(8);
  const commandView = new DataView(commandBuffer);
  commandView.setBigUint64(0, 42n, true);
  await manager.flush_pdu_raw_data('sample_robot', 'actuator_command', commandBuffer);

  await manager.stop_service();
}

main().catch((err) => {
  console.error(err);
  process.exit(1);
});
```

A ready-to-run version of this script lives in [`examples/basic-client.js`](examples/basic-client.js) together with a minimal [`sample-config.json`](examples/sample-config.json). The checked-in example imports from the local `src` directory so it can be executed without publishing; when you depend on the npm package, import from `'hakoniwa-pdu-javascript'` as shown above. Adjust the WebSocket URI so that it matches your simulator bridge.

## API overview

| Component | Description |
| --- | --- |
| `PduManager` | High-level faÃ§ade that loads the channel configuration, manages buffers, and coordinates the transport. Use this class to declare PDUs, send raw data, and request refreshed payloads. |
| `WebSocketCommunicationService` / `WebSocketServerCommunicationService` | Transport adapters that implement the Hakoniwa wire protocol over WebSocket as a client or server respectively. |
| `PduChannelConfig` | Loads channel metadata from a JSON configuration file generated by Hakoniwa tooling. |
| `PduConvertor` | Bridges between binary PDUs and the generated JavaScript codec functions. Helpful when marshalling structured data. |
| `RemotePduServiceClientManager` / `RemotePduServiceServerManager` | Utilities for building RPC clients and servers on top of the PDU transport. |
| `pdu_utils`, `pdu_constants` | Lower-level helpers and constant values that are shared across the implementation. |

### Common workflows

1. **Initialize the manager** â€“ `manager.initialize(configPath, transport)` to load your channel map and attach a transport instance.
2. **Start the transport** â€“ `await manager.start_service('ws://...')` for clients or `await transport.start_service(...)` for servers.
3. **Declare PDUs** â€“ `declare_pdu_for_read`, `declare_pdu_for_write`, or `declare_pdu_for_readwrite` depending on your data flow.
4. **Read or write** â€“ `read_pdu_raw_data` returns the latest payload as an `ArrayBuffer`, while `flush_pdu_raw_data` pushes an `ArrayBuffer` to the simulator.
5. **Perform RPC (optional)** â€“ use the `RemotePduService*Manager` classes alongside `ServiceConfig` when you need request/response semantics.

Refer to the inline JSDoc in [`src`](src) for detailed method signatures and behavior.

## Running the example locally

```bash
# Install dependencies once
git clone https://github.com/hakoniwalab/hakoniwa-pdu-javascript.git
cd hakoniwa-pdu-javascript
npm install

# Start (or point to) a Hakoniwa-compatible WebSocket bridge on localhost:8080
# then run the sample client
node examples/basic-client.js
```

The example uses the [`examples/sample-config.json`](examples/sample-config.json) configuration to describe two PDUs:

- `sensor_state` (channel 1, read-only) â€“ an 8-byte payload containing a timestamp.
- `actuator_command` (channel 2, write-only) â€“ an 8-byte payload for actuator commands.

Update the channel information so that it matches the configuration generated for your robot.

## Testing

Integration tests require a Python WebSocket echo server that understands the Hakoniwa framing. Start the Python server in one terminal and run the Jest test suite in another:

```bash
npm test
```

The test runner executes both unit tests and the end-to-end scenarios targeting the running Python bridge.

## Packaging & publishing

The project is configured for direct publishing to the npm registry. Useful commands:

```bash
# Lint & test before publishing
npm test

# Create a tarball for local inspection
npm pack

# Publish a new version (remember to bump the version first)
npm publish --access public
```

Only the runtime sources (`src`), README, and LICENSE are included in the published package to keep installs lean.

## License

This project is released under the [MIT License](LICENSE).
